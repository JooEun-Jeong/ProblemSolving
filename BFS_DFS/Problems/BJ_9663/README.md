# Back Tracking의 전형적인 문제
---

## **1. `is_available()` 호출 제거 (시간 단축)**
**첫 번째 코드:**  
- `is_available()` 함수를 호출하여 `O(n)`의 반복문을 수행하여 퀸의 배치 가능 여부를 검사.  
- 즉, `dfs()`가 호출될 때마다 매번 `O(n)`의 추가 연산이 발생함.

**두 번째 코드:**  
- **배열(`a`, `b`, `c`)을 이용해 즉시 체크 가능** → `O(1)` 시간 복잡도.  
- 불필요한 반복을 제거하여 탐색 속도를 극적으로 개선.

✅ **차이점:**  
**첫 번째 코드**는 `is_available()`을 호출하는데 `O(n)`의 시간이 걸림.  
**두 번째 코드**는 즉시 `O(1)`로 배치 가능 여부를 확인할 수 있음.

---

## **2. `candidates` 리스트 vs. 불리언 배열 사용**
**첫 번째 코드 (`candidates` 리스트 사용)**  
- `candidates.append(i)`, `candidates.pop()`을 사용하여 퀸의 배치를 관리.
- 리스트의 동적 변경이 자주 일어나므로 **메모리 할당 비용이 추가**됨.

**두 번째 코드 (`a, b, c` 불리언 배열 사용)**  
- `a[j]`, `b[i+j]`, `c[i-j+n-1]` 불리언 배열을 활용하여 방문 여부를 체크.
- `True` / `False` 값만 변경하면 되므로 **리스트 추가·삭제보다 훨씬 빠름**.

✅ **차이점:**  
- 리스트를 사용하는 **첫 번째 코드**는 메모리 관리 비용이 추가로 발생.  
- 불리언 배열을 활용하는 **두 번째 코드**는 훨씬 빠르게 상태를 관리할 수 있음.

---

## **3. 대각선 체크 방식의 차이**
**첫 번째 코드 (대각선 충돌 확인 연산)**
```python
if abs(candidates[queen_row] - current_col) == current_row - queen_row:
```
- `abs()` 연산이 필요함 → 계산량이 증가함.

**두 번째 코드 (배열을 통한 즉시 확인)**
```python
if not(a[j] or b[i+j] or c[i-j+n-1]):
```
- **`b[i+j]` → 오른쪽 대각선 (↘) 충돌 체크**  
  - `i`(현재 행) + `j`(현재 열)가 고유한 값이므로 배열로 쉽게 관리 가능.
- **`c[i-j+n-1]` → 왼쪽 대각선 (↙) 충돌 체크**  
  - `i - j`가 음수가 될 수 있으므로 `+ (n-1)`을 더해 양수로 변환.

✅ **차이점:**  
- 첫 번째 코드에서는 `abs()` 연산이 필요하여 계산량 증가.  
- 두 번째 코드는 **배열 인덱스만 확인하면 되므로 훨씬 빠름** (`O(1)` 연산).

---

## **4. 백트래킹(Backtracking) 최적화**
**첫 번째 코드 (느림)**
```python
candidates.append(i)
dfs(n, cur_row + 1, candidates)
candidates.pop()
```
- **리스트 추가/삭제 연산이 백트래킹마다 필요**하여 **메모리 비용과 속도 저하** 발생.

**두 번째 코드 (빠름)**
```python
a[j] = b[i+j] = c[i-j+n-1] = True
dfs(i+1)
a[j] = b[i+j] = c[i-j+n-1] = False  # 백트래킹
```
- **배열 값을 `True`/`False`로만 바꾸면 됨** → 메모리 복잡도 절감.

✅ **차이점:**  
- **첫 번째 코드**는 리스트를 동적으로 조작해야 하므로 속도가 느림.  
- **두 번째 코드**는 **불리언 배열을 활용하여 즉시 상태를 업데이트**하므로 훨씬 빠름.

---

## **결론: 두 번째 코드가 약 4배 빠른 이유**
| 항목 | 첫 번째 코드 (느림) | 두 번째 코드 (빠름) |
|------|----------------|----------------|
| **배치 가능 여부 검사** | `is_available()` 호출 (`O(n)`) | `O(1)` 불리언 배열 활용 |
| **대각선 충돌 체크** | `abs()` 연산 사용 | 배열 인덱스로 즉시 확인 |
| **퀸 상태 저장** | `candidates.append/pop()` (리스트 동적 변경) | `True/False`만 변경 |
| **백트래킹 시 비용** | 리스트 조작 → 느림 | 불리언 값 변경 → 빠름 |

🚀 **최적화 포인트:**  
1. **배열을 이용한 `O(1)` 체크** → `is_available()`을 없애 불필요한 연산 제거.  
2. **`abs()` 연산 제거** → 배열로 대각선 충돌 여부를 빠르게 확인.  
3. **리스트 대신 불리언 배열 사용** → 리스트 추가/삭제 비용 절약.  
4. **백트래킹 연산 최적화** → 단순 `True/False` 변경으로 탐색 속도 개선.

### **✅ 핵심 요약**
- **첫 번째 코드:** `O(n!)`에 가까운 복잡도로 동작 (추가적인 리스트 조작 비용 발생).
- **두 번째 코드:** **불리언 배열**을 활용하여 `O(1)`로 상태 체크하여 **약 4배 빠름**.

📌 **실전 백트래킹 문제를 풀 때 최적화 전략**  
- **불필요한 함수 호출을 줄이자.** (`O(n)` 대신 `O(1)` 검사 활용)  
- **배열을 적극 활용하여 즉시 상태 체크하자.**  
- **리스트 대신 `True/False` 값 변경 방식이 더 빠르다.**  
- **대각선 체크 시 `abs()` 대신 인덱스 기반 접근을 고려하자.**  

✅ **즉, 백트래킹을 사용할 때 가지치기(Pruning)와 빠른 상태 업데이트가 핵심!** 🚀

*Generated using ChatGPT by OpenAI*