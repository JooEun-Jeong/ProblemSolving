### 백트래킹 적용 과정

1. 모든 경우의 수를 탐색해야 한다면 DFS (재귀) 구조부터 만든다.
2. "선택한 숫자"를 저장할 배열과 "방문 여부"를 체크할 배열을 만든다.
3. 탐색이 끝났을 때 백트래킹을 위해 방문 여부를 원래 상태로 돌려놓는다.
4. 중복된 경우를 방지하기 위해 prev 변수를 활용하여 같은 depth에서 같은 숫자를 건너뛴다.
5. 문제에 따라 추가적인 가지치기 (Pruning)를 고민한다

#### 핵심 포인트

- 백트래킹은 "모든 경우를 탐색하되, 불필요한 경우는 미리 제거" 하는 기법이다.
- 순열 문제에서는 재귀(DFS) + 방문 체크 + 백트래킹 을 적용하면 해결할 수 있다.
- 중복을 방지하려면 정렬 후 prev 변수를 사용하여 같은 depth에서 같은 숫자를 두 번 고르지 않도록 한다.

#### 2차원 배열을 사용해야 될 것 같은 상황이 발생할 때 `ex) N-Queen`

1. **상태를 최소한으로 저장하라**

   - 비효율적인 방식: boolean[][] 배열을 사용하여 직접 보드를 관리하면, 상태를 저장하고 복구하는 데 많은 연산이 필요함.
   - 효율적인 방식:
     N-Queen 문제에서는 1차원 배열 3개를 활용하여 퀸의 배치 가능 여부만 관리하면 됨.  
     예를 들어, boolean[] col, boolean[] diag1, boolean[] diag2를 사용하면 O(1)로 위치 검증이 가능.

2. **한 줄(행 or 열) 단위로 배치하라**

   - 불필요한 탐색을 피하기 위해, 한 행(row) 또는 한 열(column) 단위로 탐색하는 것이 중요함.
   - N-Queen에서는 한 행에 하나의 퀸만 배치되므로, 각 행을 하나씩 채우며 진행하면 탐색 범위를 줄일 수 있음.

3. **방문 기록을 빠르게 복구하라**

   - 백트래킹의 핵심은 상태 변경 후, 원래 상태로 되돌리는 것(Backtrack).
   - boolean[][] 같은 2차원 배열을 사용하면 복구할 때 반복문이 필요해 시간이 오래 걸림. 대신, 간단한 boolean[] 상태 변경을 활용하면 빠르게 복구 가능.

4. **가지치기(Pruning) 활용** → 불필요한 경우 미리 continue.
5. **DFS와 백트래킹을 결합하라** → 깊이 우선 탐색으로 문제 해결.
6. **미리 계산하여 중복 연산을 피하라** → 메모이제이션 활용.
7. **대칭성을 활용하여 탐색 범위 줄이기** → 경우의 수 줄이기.
---
#### Backtracking의 기본 골자가 되는 문제들

- 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
  - [N과 M 1](https://www.acmicpc.net/problem/15649)
- 1부터 N까지의 수를 중복 없이 M개 고른 수열 + 오름차순
  - [N과 M 2](https://www.acmicpc.net/problem/15650)
- 1부터 N까지의 수를 중복해서 M개 고른 수열
  - [N과 M 3](https://www.acmicpc.net/problem/15651)
- 1부터 N까지의 수를 중복해서 M개 고른 수열 + 비내림차순
  - [N과 M 4](https://www.acmicpc.net/problem/15652)
- N개의 자연수 중에서 M개를 중복없이 고른 수열
  - [N과 M 5](https://www.acmicpc.net/problem/15654)
- N개의 자연수 중에서 M개를 중복없이 고른 수열 + 오름차순
  - [N과 M 6](https://www.acmicpc.net/problem/15655)
- N개의 자연수 중에서 M개를 중복해서 고른 수열
  - [N과 M 7](https://www.acmicpc.net/problem/15656)
- N개의 수를 중복해서 M개 고른 수열 + 비내림차순
  - [N과 M 8](https://www.acmicpc.net/problem/15657)
- N개의 자연수 중에서 M개를 중복없이 고른 수열 + 오름차순
  - [N과 M 9](https://www.acmicpc.net/problem/15663)
