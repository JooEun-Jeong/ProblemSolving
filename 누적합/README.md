누적합(구간 합)과 관련된 코딩테스트 문제는 주로 **구간의 합을 빠르게 구하는 문제**로 출제됩니다. 대표적인 유형과 풀이법을 소개할게요.

---

### 🔹 1. 기본적인 누적합 개념

배열의 특정 구간 `[L, R]`의 합을 **빠르게 계산**해야 하는 경우, 단순한 `for` 문을 사용하면 **O(N)** 시간이 걸립니다.  
그러나 **누적합 (Prefix Sum)** 을 활용하면 **O(1)** 만에 구할 수 있습니다.

💡 **누적합 배열 정의:**

```python
S[i] = A[0] + A[1] + ... + A[i-1]  (1-based index)
```

여기서 `A[i]`는 원본 배열이고, `S[i]`는 `A`의 **0부터 i-1까지의 합**입니다.

✅ **구간 합 구하는 공식**
\[
\text{sum}(L, R) = S[R+1] - S[L]
\]

---

### 🔹 2. 대표적인 누적합 문제 유형

#### ✅ (1) 구간 합 빠르게 구하기

**문제 예시:**

```text
N개의 숫자가 주어지고, M개의 질의가 주어진다. 각 질의에서 [L, R] 구간의 합을 구하라.
```

**풀이:**

1. **누적합 배열을 미리 생성** → `O(N)`
2. **구간합을 빠르게 계산** → `O(1)`

**코드 (Python)**

```python
import sys

# 입력 받기
N, M = map(int, sys.stdin.readline().split())
A = list(map(int, sys.stdin.readline().split()))

# 누적합 배열 만들기 (1-based)
S = [0] * (N + 1)
for i in range(1, N + 1):
    S[i] = S[i - 1] + A[i - 1]

# 질의 처리
for _ in range(M):
    L, R = map(int, sys.stdin.readline().split())
    print(S[R] - S[L - 1])  # O(1) 연산
```

📌 **시간 복잡도:** `O(N + M)`

---

#### ✅ (2) 부분합 (투 포인터 활용)

**문제 예시:**

```text
N개의 숫자가 주어진다. 합이 S 이상이 되는 가장 짧은 연속된 부분 배열의 길이를 구하라.
```

**풀이:**

1. **누적합을 활용하면 `O(N^2)`** 이지만, **투 포인터 기법**을 사용하면 `O(N)` 해결 가능.
2. `start`와 `end` 포인터를 이동하면서 부분합을 유지.

**코드 (Python)**

```python
N, S = map(int, input().split())
A = list(map(int, input().split()))

start, end, total = 0, 0, 0
min_length = float('inf')

while end < N:
    total += A[end]
    end += 1

    while total >= S:
        min_length = min(min_length, end - start)
        total -= A[start]
        start += 1

print(min_length if min_length != float('inf') else 0)
```

📌 **시간 복잡도:** `O(N)`

---

#### ✅ (3) 2차원 구간 합 (누적합 DP)

**문제 예시:**

```text
N×N 크기의 행렬이 주어질 때, 여러 개의 (x1, y1) ~ (x2, y2) 구간 합을 구하라.
```

**풀이:**

1. **2차원 누적합 배열 `S[i][j]` 생성**
2. **구간 합 공식 적용**
   \[
   S(x1, y1, x2, y2) = S[x2][y2] - S[x1-1][y2] - S[x2][y1-1] + S[x1-1][y1-1]
   \]

**코드 (Python)**

```python
N, M = map(int, input().split())
A = [list(map(int, input().split())) for _ in range(N)]

# 2D 누적합 구하기
S = [[0] * (N + 1) for _ in range(N + 1)]
for i in range(1, N + 1):
    for j in range(1, N + 1):
        S[i][j] = A[i-1][j-1] + S[i-1][j] + S[i][j-1] - S[i-1][j-1]

# 질의 처리
for _ in range(M):
    x1, y1, x2, y2 = map(int, input().split())
    print(S[x2][y2] - S[x1-1][y2] - S[x2][y1-1] + S[x1-1][y1-1])
```

📌 **시간 복잡도:** `O(N^2 + M)`

---

### 🔹 3. 정리

| 문제 유형                     | 핵심 개념    | 시간 복잡도  |
| ----------------------------- | ------------ | ------------ |
| **구간 합 구하기**            | 1차원 누적합 | `O(N + M)`   |
| **부분합 (최소 길이 구하기)** | 투 포인터    | `O(N)`       |
| **2차원 구간 합**             | 누적합 DP    | `O(N^2 + M)` |

누적합을 활용하면 **구간 합을 빠르게 구하는 문제를 최적화**할 수 있어요!  
특히 **1차원/2차원 누적합, 투 포인터**와 함께 익혀두면 좋습니다. 🚀

*Generated by ChatGPT*