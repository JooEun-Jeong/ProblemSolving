ê¸°í•˜í•™(Geometry) ê´€ë ¨ ì½”ë”© ë¬¸ì œ ìœ í˜•ì€ ì—¬ëŸ¬ ê°€ì§€ê°€ ìˆìœ¼ë©°, ê¸°ë³¸ ê°œë…ì„ ì˜ ì´í•´í•˜ë©´ í’€ê¸° ì‰¬ì›Œì§„ë‹¤. ì—¬ê¸°ì„œëŠ” **ìœ í˜•ë³„ ë¬¸ì œ ì˜ˆì‹œì™€ í•´ê²° ë°©ë²•**ì„ ì†Œê°œí• ê²Œ.

---

## ğŸ“Œ 1. **ê¸°ë³¸ì ì¸ ê¸°í•˜ ì—°ì‚°**
### âœ” ìœ í˜•:
- ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬ êµ¬í•˜ê¸°
- ì„ ë¶„ê³¼ ì„ ë¶„ì˜ êµì°¨ ì—¬ë¶€ íŒë‹¨
- ë‚´ì (Dot Product), ì™¸ì (Cross Product) ê³„ì‚°

### ğŸ›  í•´ê²° ë°©ë²•:
- ìœ í´ë¦¬ë“œ ê±°ë¦¬ ê³µì‹:  
  \[
  d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
  \]
- ì™¸ì ì„ ì´ìš©í•œ **CCW(Counter Clockwise) ì•Œê³ ë¦¬ì¦˜**ì„ í™œìš©í•´ ì ë“¤ì˜ ë°©í–¥ì„ íŒë‹¨í•  ìˆ˜ ìˆìŒ.

#### âœ… ì˜ˆì œ: ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬
```java
public double distance(double x1, double y1, double x2, double y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
}
```

#### âœ… ì˜ˆì œ: CCW ì•Œê³ ë¦¬ì¦˜ (ë°˜ì‹œê³„ ë°©í–¥ í™•ì¸)
```java
public int ccw(int x1, int y1, int x2, int y2, int x3, int y3) {
    int result = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);
    if (result > 0) return 1;  // ë°˜ì‹œê³„ ë°©í–¥
    if (result < 0) return -1; // ì‹œê³„ ë°©í–¥
    return 0;  // ì¼ì§ì„ 
}
```

---

## ğŸ“Œ 2. **ë‹¤ê°í˜• ë¬¸ì œ**
### âœ” ìœ í˜•:
- ë‹¤ê°í˜•ì˜ ë©´ì  êµ¬í•˜ê¸° (**ì‹ ë°œëˆ ê³µì‹**)
- ë‹¤ê°í˜• ë‚´ë¶€ ì  íŒë³„ (**í™€ì§ ë²•ì¹™ / ë°˜ì§ì„  êµì°¨ë²•**)
- ë³¼ë¡ ë‹¤ê°í˜•(Convex Hull) êµ¬í•˜ê¸° (**Andrewâ€™s Algorithm, Grahamâ€™s scan**)

### ğŸ›  í•´ê²° ë°©ë²•:
#### âœ… ì˜ˆì œ: ì‹ ë°œëˆ ê³µì‹ì„ ì´ìš©í•œ ë‹¤ê°í˜• ë©´ì  êµ¬í•˜ê¸°
```java
public double polygonArea(int[] x, int[] y, int n) {
    double sum1 = 0, sum2 = 0;
    for (int i = 0; i < n; i++) {
        int next = (i + 1) % n;
        sum1 += x[i] * y[next];
        sum2 += y[i] * x[next];
    }
    return Math.abs(sum1 - sum2) / 2.0;
}
```

#### âœ… ì˜ˆì œ: ì ì´ ë‹¤ê°í˜• ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸ (ë°˜ì§ì„  êµì°¨ë²•)
```java
public boolean isInsidePolygon(int[] x, int[] y, int n, int px, int py) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        int next = (i + 1) % n;
        if ((y[i] > py) != (y[next] > py)) {
            double intersectX = (double)(x[next] - x[i]) * (py - y[i]) / (y[next] - y[i]) + x[i];
            if (px < intersectX) count++;
        }
    }
    return count % 2 == 1;
}
```

---

## ğŸ“Œ 3. **ë³¼ë¡ ê»ì§ˆ(Convex Hull) ë¬¸ì œ**
### âœ” ìœ í˜•:
- ì£¼ì–´ì§„ ì ë“¤ì„ í¬í•¨í•˜ëŠ” ìµœì†Œ ë‹¤ê°í˜• ì°¾ê¸° (**Convex Hull**)
- ë³¼ë¡ ë‹¤ê°í˜•ì˜ ì„±ì§ˆì„ ì´ìš©í•œ ë¬¸ì œ

### ğŸ›  í•´ê²° ë°©ë²•:
- **Graham's scan** ë˜ëŠ” **Andrewâ€™s Algorithm**ì„ ì‚¬ìš©í•˜ì—¬ Convex Hullì„ êµ¬í•  ìˆ˜ ìˆìŒ.
- CCW íŒë³„ì„ í™œìš©í•˜ì—¬ ë³¼ë¡ ë‹¤ê°í˜•ì˜ ì ë“¤ì„ ì„ íƒí•¨.

#### âœ… ì˜ˆì œ: Convex Hull (Andrewâ€™s Algorithm)
```java
import java.util.*;

public class ConvexHull {
    static class Point implements Comparable<Point> {
        int x, y;
        Point(int x, int y) { this.x = x; this.y = y; }
        public int compareTo(Point p) { return x == p.x ? y - p.y : x - p.x; }
    }

    public static int ccw(Point a, Point b, Point c) {
        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    }

    public static List<Point> convexHull(Point[] points) {
        Arrays.sort(points);
        List<Point> hull = new ArrayList<>();

        for (int phase = 0; phase < 2; phase++) {
            int start = hull.size();
            for (Point p : points) {
                while (hull.size() >= start + 2 && ccw(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p) <= 0) {
                    hull.remove(hull.size() - 1);
                }
                hull.add(p);
            }
            hull.remove(hull.size() - 1);
            Collections.reverse(Arrays.asList(points));
        }

        return hull;
    }
}
```

---

## ğŸ“Œ 4. **ì›ê³¼ ì§ì„  ë¬¸ì œ**
### âœ” ìœ í˜•:
- ë‘ ì›ì´ ì ‘í•˜ëŠ”ì§€ í™•ì¸
- ì›ê³¼ ì„ ë¶„ì˜ êµì°¨ ì—¬ë¶€
- ì‚¼ê°í˜• ë‚´ì ‘ì›/ì™¸ì ‘ì› êµ¬í•˜ê¸°

### ğŸ›  í•´ê²° ë°©ë²•:
- ë‘ ì›ì´ ì ‘í•˜ëŠ”ì§€ í™•ì¸í•˜ë ¤ë©´ ì¤‘ì‹¬ ê±°ë¦¬ì™€ ë°˜ì§€ë¦„ì„ ë¹„êµ
- ì›ê³¼ ì§ì„ ì˜ ê±°ë¦¬ëŠ” **ì ê³¼ ì§ì„  ì‚¬ì´ ê±°ë¦¬ ê³µì‹** ì‚¬ìš©

#### âœ… ì˜ˆì œ: ë‘ ì›ì´ ì ‘í•˜ëŠ”ì§€ í™•ì¸
```java
public boolean isCircleTouching(int x1, int y1, int r1, int x2, int y2, int r2) {
    double dist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    return dist == r1 + r2 || dist == Math.abs(r1 - r2);
}
```

---

## ğŸ“Œ 5. **ì‚¼ê°í˜• ë¬¸ì œ**
### âœ” ìœ í˜•:
- ì‚¼ê°í˜•ì˜ ë‚´ì‹¬, ì™¸ì‹¬, ìˆ˜ì‹¬ êµ¬í•˜ê¸°
- ì‚¼ê°í˜•ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
- ì‚¼ê°í˜•ì˜ ìœ í˜• íŒë³„ (ì§ê°ì‚¼ê°í˜•, ë‘”ê°ì‚¼ê°í˜• ë“±)

### ğŸ›  í•´ê²° ë°©ë²•:
- ì„¸ ë³€ì´ `a, b, c`ì¼ ë•Œ, ì‚¼ê°í˜•ì´ ì¡´ì¬í•˜ë ¤ë©´ **ì‚¼ê° ë¶€ë“±ì‹**ì´ ì„±ë¦½í•´ì•¼ í•¨:  
  \[
  a + b > c, \quad b + c > a, \quad c + a > b
  \]
- **í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬**ë¥¼ ì´ìš©í•´ ì‚¼ê°í˜•ì´ ì§ê°ì¸ì§€ íŒë³„ ê°€ëŠ¥

#### âœ… ì˜ˆì œ: ì‚¼ê°í˜•ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
```java
public boolean isTriangle(int a, int b, int c) {
    return (a + b > c) && (b + c > a) && (c + a > b);
}
```

#### âœ… ì˜ˆì œ: ì‚¼ê°í˜•ì´ ì§ê°ì¸ì§€ íŒë³„
```java
public boolean isRightTriangle(int a, int b, int c) {
    int[] sides = {a, b, c};
    Arrays.sort(sides);
    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2];
}
```

---

## ğŸš€ ê¸°í•˜ ë¬¸ì œë¥¼ í‘¸ëŠ” íŒ
1. **ê¸°ë³¸ ì—°ì‚°(ê±°ë¦¬, ë‚´ì , ì™¸ì , CCW)**ì„ í™•ì‹¤íˆ ìµíˆì.
2. **ë¶€ë™ì†Œìˆ˜ì  ì˜¤ì°¨ë¥¼ ê³ ë ¤**í•´ `double`ì´ ì•„ë‹Œ **ì •ìˆ˜ ì—°ì‚°ì„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸**.
3. **ì‹ ë°œëˆ ê³µì‹, CCW, Convex Hull ë“± ì•Œê³ ë¦¬ì¦˜ì„ ìˆ™ì§€**í•˜ì.
4. **í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ ë‹¤ì–‘í•˜ê²Œ ê³ ë ¤**í•˜ì (íŠ¹íˆ ì§ì„ , ê²¹ì¹˜ëŠ” ì  ë“± ê²½ê³„ ìƒí™©).
5. **ë°˜ì˜¬ë¦¼ ê´€ë ¨ ë¬¸ì œ**ëŠ” `printf("%.1f")` ë“± **ì¶œë ¥ í˜•ì‹**ì„ ì˜ ë§ì¶°ì•¼ í•¨.




### ğŸ“Œ ê¸°í•˜í•™ ë¬¸ì œë¥¼ í’€ ë•Œ í•„ìš”í•œ **ìˆ˜í•™ ê³µì‹ ì •ë¦¬**

---

### âœ… 1. **ê¸°ë³¸ ê¸°í•˜ ì—°ì‚°**
#### ğŸ“Œ ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬ (Euclidean Distance)
\[
d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\]

#### ğŸ“Œ ë‚´ì  (Dot Product)
\[
\mathbf{A} \cdot \mathbf{B} = x_1 x_2 + y_1 y_2
\]
- **ìš©ë„**: ë‘ ë²¡í„°ê°€ ì§êµ(90ë„)í•˜ëŠ”ì§€ íŒë³„ (ë‚´ì  = 0ì´ë©´ ì§êµ)

#### ğŸ“Œ ì™¸ì  (Cross Product)
\[
\mathbf{A} \times \mathbf{B} = x_1 y_2 - y_1 x_2
\]
- **ìš©ë„**: CCW ì•Œê³ ë¦¬ì¦˜(ë°˜ì‹œê³„ ë°©í–¥ íŒë³„), ì‚¼ê°í˜• ë©´ì  ê³„ì‚°

#### ğŸ“Œ CCW (Counter Clockwise, ë°˜ì‹œê³„ ë°©í–¥ íŒë³„)
\[
CCW = (x_2 - x_1) \cdot (y_3 - y_1) - (y_2 - y_1) \cdot (x_3 - x_1)
\]
- `CCW > 0` â†’ ë°˜ì‹œê³„ ë°©í–¥
- `CCW < 0` â†’ ì‹œê³„ ë°©í–¥
- `CCW = 0` â†’ ì¼ì§ì„ 

---

### âœ… 2. **ë‹¤ê°í˜• ê´€ë ¨ ê³µì‹**
#### ğŸ“Œ ì‹ ë°œëˆ ê³µì‹ (Shoelace Theorem, ë‹¤ê°í˜• ë©´ì )
\[
\text{Area} = \frac{1}{2} \left| \sum (x_i y_{i+1}) - \sum (y_i x_{i+1}) \right|
\]
- **ìˆœì„œ**: `(x1, y1), (x2, y2), ..., (xn, yn)` ë§ˆì§€ë§‰ ì  ë‹¤ìŒì— ì²« ì ì„ ë„£ì–´ì•¼ í•¨.

#### ğŸ“Œ ë‹¤ê°í˜• ë‚´ë¶€ íŒë³„ (í™€ì§ ë²•ì¹™, Ray Crossing Algorithm)
- ì  **(px, py)**ê°€ ë‹¤ê°í˜• ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë°©ë²•:
  - ë‹¤ê°í˜•ì˜ í•œìª½ ë°©í–¥ìœ¼ë¡œ **ë°˜ì§ì„ **ì„ ê¸‹ê³ , ë‹¤ê°í˜•ì˜ ì„ ë¶„ê³¼ êµì°¨í•˜ëŠ” íšŸìˆ˜ë¥¼ ì…ˆ.
  - êµì°¨ íšŸìˆ˜ê°€ **í™€ìˆ˜ë©´ ë‚´ë¶€, ì§ìˆ˜ë©´ ì™¸ë¶€**.

---

### âœ… 3. **ì‚¼ê°í˜• ê´€ë ¨ ê³µì‹**
#### ğŸ“Œ ì‚¼ê°í˜• ì¡´ì¬ ì—¬ë¶€ (ì‚¼ê° ë¶€ë“±ì‹)
\[
a + b > c, \quad b + c > a, \quad c + a > b
\]
- ìœ„ ì¡°ê±´ì´ ì„±ë¦½í•˜ë©´ ì‚¼ê°í˜•ì„ ë§Œë“¤ ìˆ˜ ìˆìŒ.

#### ğŸ“Œ ì‚¼ê°í˜• ë„“ì´ ê³µì‹ (í—¤ë¡  ê³µì‹)
\[
s = \frac{a + b + c}{2}
\]
\[
\text{Area} = \sqrt{s(s-a)(s-b)(s-c)}
\]
- **a, b, c**: ì‚¼ê°í˜•ì˜ ì„¸ ë³€

#### ğŸ“Œ ì‚¼ê°í˜•ì˜ ë‚´ì‹¬ (Incenter, ë‚´ì ‘ì›ì˜ ì¤‘ì‹¬)
\[
I_x = \frac{a x_A + b x_B + c x_C}{a + b + c}, \quad
I_y = \frac{a y_A + b y_B + c y_C}{a + b + c}
\]
- **(xA, yA), (xB, yB), (xC, yC)**: ì‚¼ê°í˜•ì˜ ì„¸ ì  ì¢Œí‘œ
- **a, b, c**: ê°ê°ì˜ ë³€ ê¸¸ì´

#### ğŸ“Œ ì‚¼ê°í˜•ì˜ ì™¸ì‹¬ (Circumcenter, ì™¸ì ‘ì›ì˜ ì¤‘ì‹¬)
\[
(x, y) = \left( \frac{(x_A^2 + y_A^2)(y_B - y_C) + (x_B^2 + y_B^2)(y_C - y_A) + (x_C^2 + y_C^2)(y_A - y_B)}{2 D}, \frac{(x_A^2 + y_A^2)(x_C - x_B) + (x_B^2 + y_B^2)(x_A - x_C) + (x_C^2 + y_C^2)(x_B - x_A)}{2 D} \right)
\]
\[
D = x_A(y_B - y_C) + x_B(y_C - y_A) + x_C(y_A - y_B)
\]

---

### âœ… 4. **ì›ê³¼ ê´€ë ¨ëœ ê³µì‹**
#### ğŸ“Œ ë‘ ì›ì´ ì ‘í•˜ëŠ”ì§€ íŒë³„
\[
\text{distance} = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\]
- ì ‘í•  ì¡°ê±´:
  - **ì™¸ì ‘**: `distance = r1 + r2`
  - **ë‚´ì ‘**: `distance = |r1 - r2|`
  - **ê²¹ì¹¨**: `distance < r1 + r2`
  - **ë–¨ì–´ì§**: `distance > r1 + r2`

#### ğŸ“Œ ì ê³¼ ì§ì„  ì‚¬ì´ ê±°ë¦¬
ì§ì„ ì˜ ë°©ì •ì‹ì´ **Ax + By + C = 0**ì¼ ë•Œ, ì  (px, py)ì—ì„œ ì§ì„ ê¹Œì§€ì˜ ê±°ë¦¬:
\[
d = \frac{|A p_x + B p_y + C|}{\sqrt{A^2 + B^2}}
\]

---

### âœ… 5. **Convex Hull (ë³¼ë¡ ê»ì§ˆ)**
#### ğŸ“Œ Graham's scanì„ ì´ìš©í•œ ì •ë ¬ ê¸°ì¤€
- ê¸°ì¤€ì  **P**ë¥¼ ì¡ê³ , ê° ì ì„ **ë°˜ì‹œê³„ ë°©í–¥ìœ¼ë¡œ ì •ë ¬**í•˜ê¸° ìœ„í•´ **ê°ë„ë¥¼ ì •ë ¬**í•´ì•¼ í•¨.
- ë‘ ì  **A, B**ì— ëŒ€í•´ ê¸°ì¤€ì  **P**ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ëŠ” ë°©ë²•:
\[
\theta = \tan^{-1} \left(\frac{y_B - y_A}{x_B - x_A}\right)
\]

---

### âœ… 6. **ë²¡í„°ì™€ íšŒì „**
#### ğŸ“Œ ë²¡í„° íšŒì „ (2D íšŒì „ ë³€í™˜)
- ì  (x, y)ë¥¼ ì›ì  ì¤‘ì‹¬ìœ¼ë¡œ **Î¸ë§Œí¼ íšŒì „**ì‹œí‚¨ ìƒˆë¡œìš´ ì¢Œí‘œ (x', y'):
\[
x' = x \cos\theta - y \sin\theta
\]
\[
y' = x \sin\theta + y \cos\theta
\]

---

### âœ… 7. **ì§ì„ ê³¼ ì„ ë¶„ êµì°¨ ì—¬ë¶€**
#### ğŸ“Œ ë‘ ì„ ë¶„ (A, B)ì™€ (C, D)ê°€ êµì°¨í•˜ëŠ”ì§€ íŒë³„
- CCWë¥¼ í™œìš©í•˜ì—¬ ë‘ ì„ ë¶„ì´ êµì°¨í•˜ëŠ”ì§€ íŒë³„:
\[
CCW(A, B, C) \times CCW(A, B, D) < 0
\]
\[
CCW(C, D, A) \times CCW(C, D, B) < 0
\]
- ìœ„ ë‘ ì¡°ê±´ì„ ë§Œì¡±í•˜ë©´ ì„ ë¶„ì´ êµì°¨í•¨.

---

## ğŸ”¥ ì •ë¦¬
| ìœ í˜• | ê³µì‹ |
|---|---|
| ë‘ ì  ì‚¬ì´ ê±°ë¦¬ | \( \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} \) |
| ë‚´ì  | \( x_1 x_2 + y_1 y_2 \) |
| ì™¸ì  | \( x_1 y_2 - y_1 x_2 \) |
| CCW | \( (x_2 - x_1)(y_3 - y_1) - (y_2 - y_1)(x_3 - x_1) \) |
| ì‚¼ê° ë¶€ë“±ì‹ | \( a + b > c, \quad b + c > a, \quad c + a > b \) |
| ë²¡í„° íšŒì „ | \( x' = x \cos\theta - y \sin\theta, \quad y' = x \sin\theta + y \cos\theta \) |

*Generated By ChatGPT*