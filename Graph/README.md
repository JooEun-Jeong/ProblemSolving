### Graph Theory

#### 1. **DFS와 BFS를 활용한 그래프 탐색**
##### 문제 유형:
- 그래프의 모든 노드 탐색
- 연결 요소 개수 찾기
- 특정 조건을 만족하는 경로 찾기

##### 접근 방법:
- DFS(재귀 또는 스택)
- BFS(큐)

> 구체적인 문제들, 유형은 BFS_DFS폴더 참고

---

#### 2. **최단 경로 문제**
##### 문제 유형:
- 다익스트라 알고리즘
- 벨만-포드 알고리즘
- 플로이드-워셜 알고리즘

##### 접근 방법:
- 가중 그래프에서 다익스트라(단일 시작점)
- 플로이드-워셜(모든 쌍 최단 경로)

```python
import heapq

# 다익스트라 알고리즘 구현
def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    priority_queue = [(0, start)]
    
    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)
        if current_distance > distances[current_node]:
            continue
        
        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
    
    return distances

graph = {
    'A': [('B', 1), ('C', 4)],
    'B': [('C', 2), ('D', 5)],
    'C': [('D', 1)],
    'D': []
}

print("Dijkstra Result:", dijkstra(graph, 'A'))
# Output: {'A': 0, 'B': 1, 'C': 3, 'D': 4}
```

---

#### 3. **최소 스패닝 트리 (MST)**
##### 문제 유형:
- 모든 노드를 연결하는 최소 비용 구하기
- 크루스칼 알고리즘
- 프림 알고리즘

##### 접근 방법:
- 크루스칼: 간선을 정렬 후 유니온-파인드 사용
- 프림: 우선순위 큐 사용

```python
def kruskal(nodes, edges):
    parent = {node: node for node in nodes}
    
    def find(node):
        if parent[node] != node:
            parent[node] = find(parent[node])
        return parent[node]
    
    def union(node1, node2):
        root1 = find(node1)
        root2 = find(node2)
        if root1 != root2:
            parent[root2] = root1

    mst = []
    edges.sort(key=lambda x: x[2])  # 간선을 비용 기준으로 정렬
    
    for edge in edges:
        u, v, weight = edge
        if find(u) != find(v):
            union(u, v)
            mst.append(edge)
    
    return mst

nodes = ['A', 'B', 'C', 'D']
edges = [
    ('A', 'B', 1),
    ('A', 'C', 4),
    ('B', 'C', 2),
    ('B', 'D', 5),
    ('C', 'D', 1)
]

print("Kruskal MST:", kruskal(nodes, edges))
# Output: [('A', 'B', 1), ('C', 'D', 1), ('B', 'C', 2)]
```

---

#### 4. **위상 정렬**
##### 문제 유형:
- 순서가 정해진 작업의 수행 순서
- DAG(Directed Acyclic Graph)에서 사용

##### 접근 방법:
- 진입 차수(Indegree)와 큐를 활용한 Kahn’s Algorithm

```python
def topological_sort(graph):
    indegree = {node: 0 for node in graph}
    for neighbors in graph.values():
        for neighbor in neighbors:
            indegree[neighbor] += 1
    
    queue = deque([node for node in graph if indegree[node] == 0])
    topo_order = []
    
    while queue:
        node = queue.popleft()
        topo_order.append(node)
        for neighbor in graph[node]:
            indegree[neighbor] -= 1
            if indegree[neighbor] == 0:
                queue.append(neighbor)
    
    return topo_order

graph = {
    'A': ['B', 'C'],
    'B': ['D'],
    'C': ['D'],
    'D': []
}

print("Topological Sort:", topological_sort(graph))
# Output: ['A', 'B', 'C', 'D']
```

---

#### 5. **연결 요소 개수 찾기**
##### 문제 유형:
- 연결된 구성 요소의 개수를 세는 문제
- 무방향 그래프에서 주로 사용

##### 접근 방법:
- DFS 또는 BFS로 방문 여부 확인

```python
def count_connected_components(graph):
    visited = set()
    count = 0
    
    def dfs(node):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
    
    for node in graph:
        if node not in visited:
            dfs(node)
            count += 1
    
    return count

graph = {
    1: [2],
    2: [1, 3],
    3: [2],
    4: [5],
    5: [4],
    6: []
}

print("Connected Components:", count_connected_components(graph))
# Output: 3 (Components: {1,2,3}, {4,5}, {6})
```

*Generated By ChatGPT*